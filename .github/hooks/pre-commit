#!/bin/bash
# Pre-commit hook for quality checks
# Install: ln -sf ../../.github/hooks/pre-commit .git/hooks/pre-commit

set -e

echo "üîç Running pre-commit quality checks..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Track overall success
OVERALL_SUCCESS=true

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    print_status $RED "‚ùå Not in a git repository"
    exit 1
fi

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only)
STAGED_EX_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ex|exs)$' || true)
STAGED_JS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' || true)

echo "üìã Staged files: $(echo "$STAGED_FILES" | wc -l) files"

# Skip if no relevant files are staged
if [ -z "$STAGED_EX_FILES" ] && [ -z "$STAGED_JS_FILES" ]; then
    print_status $GREEN "‚úÖ No Elixir or JavaScript files staged, skipping quality checks"
    exit 0
fi

# ============================================================================
# 1. Commit Message Validation
# ============================================================================

echo ""
print_status $YELLOW "üîç Validating commit message format..."

# Check if prepare-commit-msg hook has set a conventional format
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    COMMIT_MSG=$(head -n 1 "$COMMIT_MSG_FILE")
    if [[ ! $COMMIT_MSG =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci)(\(.+\))?: .+ ]]; then
        print_status $RED "‚ùå Commit message doesn't follow conventional format"
        echo "Expected format: type(scope): description"
        echo "Types: feat, fix, docs, style, refactor, test, chore, perf, ci"
        echo "Current message: $COMMIT_MSG"
        OVERALL_SUCCESS=false
    else
        print_status $GREEN "‚úÖ Commit message format is valid"
    fi
fi

# ============================================================================
# 2. File Size and Content Checks
# ============================================================================

echo ""
print_status $YELLOW "üîç Checking file sizes and content..."

# Check for large files
LARGE_FILES=$(echo "$STAGED_FILES" | xargs -I {} find {} -size +10M 2>/dev/null || true)
if [ -n "$LARGE_FILES" ]; then
    print_status $RED "‚ùå Large files detected (>10MB):"
    echo "$LARGE_FILES"
    echo "Consider using Git LFS for large files"
    OVERALL_SUCCESS=false
else
    print_status $GREEN "‚úÖ No large files detected"
fi

# Check for merge conflict markers
CONFLICT_FILES=$(echo "$STAGED_FILES" | xargs grep -l "<<<<<<< HEAD\|>>>>>>> \|=======" 2>/dev/null || true)
if [ -n "$CONFLICT_FILES" ]; then
    print_status $RED "‚ùå Merge conflict markers found in:"
    echo "$CONFLICT_FILES"
    OVERALL_SUCCESS=false
else
    print_status $GREEN "‚úÖ No merge conflict markers found"
fi

# Check for potential secrets
SECRET_PATTERNS=(
    "password.*=.*['\"][^'\"]*['\"]"
    "api_key.*=.*['\"][^'\"]*['\"]"
    "secret.*=.*['\"][^'\"]*['\"]"
    "token.*=.*['\"][^'\"]*['\"]"
)

for pattern in "${SECRET_PATTERNS[@]}"; do
    SECRET_FILES=$(echo "$STAGED_FILES" | xargs grep -l -i "$pattern" 2>/dev/null || true)
    if [ -n "$SECRET_FILES" ]; then
        print_status $RED "‚ùå Potential hardcoded secrets found in:"
        echo "$SECRET_FILES"
        echo "Pattern: $pattern"
        OVERALL_SUCCESS=false
    fi
done

if [ "$OVERALL_SUCCESS" = true ]; then
    print_status $GREEN "‚úÖ No potential secrets detected"
fi

# ============================================================================
# 3. Elixir Quality Checks
# ============================================================================

if [ -n "$STAGED_EX_FILES" ]; then
    echo ""
    print_status $YELLOW "üîç Running Elixir quality checks..."
    
    # Check if mix is available
    if ! command_exists mix; then
        print_status $RED "‚ùå Mix not found, skipping Elixir checks"
        OVERALL_SUCCESS=false
    else
        # Format check
        print_status $YELLOW "  üìù Checking code formatting..."
        if ! mix format --check-formatted $STAGED_EX_FILES >/dev/null 2>&1; then
            print_status $RED "  ‚ùå Code formatting issues found"
            echo "  Run: mix format $STAGED_EX_FILES"
            OVERALL_SUCCESS=false
        else
            print_status $GREEN "  ‚úÖ Code formatting is correct"
        fi
        
        # Compilation check
        print_status $YELLOW "  üî® Checking compilation..."
        if ! mix compile --force --warnings-as-errors >/dev/null 2>&1; then
            print_status $RED "  ‚ùå Compilation failed or has warnings"
            echo "  Run: mix compile to see details"
            OVERALL_SUCCESS=false
        else
            print_status $GREEN "  ‚úÖ Code compiles without warnings"
        fi
        
        # Quick credo check on staged files
        if command_exists mix && mix help credo >/dev/null 2>&1; then
            print_status $YELLOW "  üéØ Running Credo analysis..."
            if ! echo "$STAGED_EX_FILES" | xargs mix credo --strict >/dev/null 2>&1; then
                print_status $YELLOW "  ‚ö†Ô∏è  Credo issues found (not blocking)"
                echo "  Run: mix credo --strict for details"
            else
                print_status $GREEN "  ‚úÖ Credo analysis passed"
            fi
        fi
    fi
fi

# ============================================================================
# 4. Frontend Quality Checks
# ============================================================================

if [ -n "$STAGED_JS_FILES" ]; then
    echo ""
    print_status $YELLOW "üîç Running frontend quality checks..."
    
    # Change to assets directory if it exists
    if [ -d "assets" ]; then
        cd assets
        
        # Check if npm is available
        if ! command_exists npm; then
            print_status $RED "‚ùå npm not found, skipping frontend checks"
            OVERALL_SUCCESS=false
        else
            # Install dependencies if needed
            if [ ! -d "node_modules" ]; then
                print_status $YELLOW "  üì¶ Installing dependencies..."
                npm ci >/dev/null 2>&1 || {
                    print_status $RED "  ‚ùå Failed to install dependencies"
                    OVERALL_SUCCESS=false
                }
            fi
            
            # Prettier check
            if [ -f "package.json" ] && npm list prettier >/dev/null 2>&1; then
                print_status $YELLOW "  üíÖ Checking code formatting..."
                if ! npm run format:check >/dev/null 2>&1; then
                    print_status $RED "  ‚ùå Code formatting issues found"
                    echo "  Run: npm run format"
                    OVERALL_SUCCESS=false
                else
                    print_status $GREEN "  ‚úÖ Code formatting is correct"
                fi
            fi
            
            # ESLint check
            if [ -f "package.json" ] && npm list eslint >/dev/null 2>&1; then
                print_status $YELLOW "  üéØ Running ESLint..."
                if ! npm run lint >/dev/null 2>&1; then
                    print_status $RED "  ‚ùå ESLint issues found"
                    echo "  Run: npm run lint for details"
                    OVERALL_SUCCESS=false
                else
                    print_status $GREEN "  ‚úÖ ESLint checks passed"
                fi
            fi
            
            # TypeScript check
            if [ -f "tsconfig.json" ]; then
                print_status $YELLOW "  üîç Running TypeScript check..."
                if ! npm run type-check >/dev/null 2>&1; then
                    print_status $YELLOW "  ‚ö†Ô∏è  TypeScript issues found (not blocking)"
                    echo "  Run: npm run type-check for details"
                else
                    print_status $GREEN "  ‚úÖ TypeScript checks passed"
                fi
            fi
        fi
        
        cd ..
    fi
fi

# ============================================================================
# 5. Test Validation (Quick Check)
# ============================================================================

if [ -n "$STAGED_EX_FILES" ]; then
    echo ""
    print_status $YELLOW "üß™ Running quick test validation..."
    
    # Check if any test files are being committed
    STAGED_TEST_FILES=$(echo "$STAGED_EX_FILES" | grep test/ || true)
    
    if [ -n "$STAGED_TEST_FILES" ]; then
        if command_exists mix; then
            print_status $YELLOW "  üß™ Running modified tests..."
            if ! echo "$STAGED_TEST_FILES" | xargs mix test >/dev/null 2>&1; then
                print_status $RED "  ‚ùå Some tests are failing"
                echo "  Run: mix test to see details"
                OVERALL_SUCCESS=false
            else
                print_status $GREEN "  ‚úÖ Modified tests are passing"
            fi
        fi
    fi
fi

# ============================================================================
# Summary
# ============================================================================

echo ""
echo "==============================================="

if [ "$OVERALL_SUCCESS" = true ]; then
    print_status $GREEN "‚úÖ All pre-commit checks passed!"
    echo ""
    print_status $GREEN "üöÄ Ready to commit"
    exit 0
else
    print_status $RED "‚ùå Pre-commit checks failed!"
    echo ""
    print_status $RED "üí° Fix the issues above before committing"
    echo ""
    echo "To bypass these checks (not recommended):"
    echo "  git commit --no-verify"
    exit 1
fi